package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"sync"
	"text/template"
	"time"

	"mongo-tester/internal/mongodb"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	reportTemplate = `
=======================================
  Scenario Report
=======================================

  Generated by mongoperf {{ .Version }}

---------------------------------------
  Config
---------------------------------------
{{ with . -}}
{{ block "config" . }}{{ end }}
{{- end }}
---------------------------------------
  Queries
---------------------------------------
{{ with .Queries -}}
{{ range . -}}
{{ block "query" . }}{{ end }}
{{- end }}
{{- end }}
=======================================
`

	configBlock = `
{{ define "config" }}
    URI:        {{ .URI }}
    Database:   {{ .Database }}
    Collection: {{ .Collection }}
    Parallel:   {{ .Parallel }}
{{ end }}
`

	queryBlock = `
{{ define "query" }}
  > Name:              {{ .Name }}
    Action:            {{ .Action }}
    QueryCount:        {{ .QueryCount }}
    ChangeCount:       {{ .ChangeCount }}
    DurationTotal:     {{ .DurationTotal }}
    Successful:        {{ if .LastError }}false{{ else }}true{{ end }}
    ErrorCount:        {{ .ErrorCount }}
    LastError:         {{ if .LastError }}{{ .LastError.Error }}{{ else }}nil{{ end }}
{{ end }}
`
)

// Report .
type Report struct {
	Version    string
	URI        string
	Database   string
	Collection string
	Parallel   int
	Queries    map[string]*ReportQuery
}

// ReportQuery .
type ReportQuery struct {
	Name   string
	Action string

	mu            *sync.Mutex
	DurationTotal time.Duration
	QueryCount    int
	ChangeCount   int
	ErrorCount    int
	LastError     error
}

// NewReportQuery .
func NewReportQuery(name, action string) *ReportQuery {
	return &ReportQuery{
		Name:          name,
		Action:        action,
		mu:            &sync.Mutex{},
		DurationTotal: time.Duration(0),
	}
}

// Update .
func (rq *ReportQuery) Update(dur time.Duration, changes int, err error) {
	rq.mu.Lock()
	defer rq.mu.Unlock()
	rq.QueryCount++
	rq.DurationTotal += dur
	rq.ChangeCount += changes
	if err != nil {
		rq.ErrorCount++
		rq.LastError = err
	}
}

func newCommandScenario() *cobra.Command {
	var (
		uri string
	)
	cmd := &cobra.Command{
		Use:   "scenario [scenario-file]",
		Short: "Run a scenario.",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			logger := logrus.New()

			cfgFile := args[0]
			scenario, err := getScenarioConfig(cfgFile)
			if err != nil {
				return err
			}

			// VALIDATE CONFIG
			if scenario.Scenario.Parallel < 1 {
				return fmt.Errorf("Scenario.Parallel must be greater than 0")
			}
			switch s := scenario.Scenario.BufferSize; {
			case s < 0:
				return fmt.Errorf("Scenario.BufferSize must be positive")
			case s == 0:
				scenario.Scenario.BufferSize = 1000
			}

			// VALIDATE COMMAND LINE ARGS
			if uri == "" {
				uri = "mongodb://localhost:27017"
			}
			logger.Printf("connecting to: %v", uri)

			// SETUP CHANNEL AND HANDLERS
			interruptCh := make(chan os.Signal, 1)
			signal.Notify(interruptCh, os.Interrupt)

			doneCh := make(chan struct{}, 0)
			resultCh := make(chan *mongodb.QueryResult, 0)

			// START INTERRUPT HANDLER
			ctx, cancelCtx := context.WithCancel(context.Background())
			go func() {
				defer cancelCtx()
				select {
				case <-interruptCh:
				case <-doneCh:
				}
			}()

			// START RESULT PROCESSING
			queries := make(map[string]*ReportQuery)
			go func() {
				for result := range resultCh {
					rq, ok := queries[*result.Query.Name]
					if !ok {
						rq = NewReportQuery(*result.Query.Name, *result.Query.Action)
					}
					delta := result.End.Sub(result.Start)
					rq.Update(delta, result.TotalChange, result.Error)
					queries[*result.Query.Name] = rq
				}
				close(doneCh)
			}()

			// START SCENARIO
			client := mongodb.NewClient(uri, mongodb.WithLogger(logger))
			go client.RunScenario(ctx, scenario.Scenario, resultCh)

			// WAIT ON COMPLETION
			select {
			case <-doneCh:
			}

			// GENERATE REPORT
			report := &Report{
				Version:    cmd.Parent().Version,
				URI:        uri,
				Database:   *scenario.Scenario.Database,
				Collection: *scenario.Scenario.Collection,
				Parallel:   scenario.Scenario.Parallel,
				Queries:    queries,
			}

			t, err := parseTemplates("report-template", reportTemplate, configBlock, queryBlock)
			if err != nil {
				return err
			}
			if err := t.Execute(defaultOutput, report); err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().StringVar(&uri, "uri", "", "MongoDB URI connection string.")
	return cmd
}

func parseTemplates(name string, tmpl ...string) (*template.Template, error) {
	if len(tmpl) == 0 {
		return nil, fmt.Errorf("no templates provided")
	}
	var t *template.Template
	for idx, tStr := range tmpl {
		if t == nil {
			t = template.New(fmt.Sprintf("%v-%d", name, idx))
		}
		var err error
		t, err = t.Parse(tStr)
		if err != nil {
			return nil, err
		}
	}
	return t, nil
}

func getScenarioConfig(cfgFile string) (*scenarioConfig, error) {
	viperInstance := viper.New()
	viperInstance.SetConfigFile(cfgFile)

	err := viperInstance.ReadInConfig()
	if err != nil {
		return nil, err
	}

	var config scenarioConfig
	if err := viperInstance.UnmarshalExact(&config); err != nil {
		return nil, err
	}
	return &config, nil
}

type scenarioConfig struct {
	Scenario *mongodb.ScenarioConfig
}
