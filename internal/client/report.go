package client

import (
	"fmt"
	"io"
	"mongoperf/internal/client/query"
	"sync"
	"text/template"
	"time"
)

// Templates .
var (
	reportTemplate = `
=======================================
  Scenario Report
=======================================

  Generated by mongoperf {{ .Version }}

---------------------------------------
  Config
---------------------------------------
{{ with . -}}
{{ block "config" . }}{{ end }}
{{- end }}
---------------------------------------
  Queries
---------------------------------------
{{ with .Results -}}
{{ range . -}}
{{ block "query" . }}{{ end }}
{{- end }}
{{- end }}
=======================================
`

	configBlock = `
{{ define "config" }}
    URI:        {{ .URI }}
    Database:   {{ .Database }}
    Collection: {{ .Collection }}
    Parallel:   {{ .Parallel }}
    Repeat:     {{ .Repeat }}
{{ end }}
`

	queryBlock = `
{{ define "query" }}
  > Name:              {{ .Name }}
    Action:            {{ .Action }}
    QueryCount:        {{ .QueryCount }}
    QueryAvg:          {{ .QueryAvg }}
    ChangeCount:       {{ .ChangeCount }}
    ChangeAvg:         {{ .ChangeAvg }}
    EPS:               {{ .EPS }}
    TotalTime:         {{ .TotalTime }}
    Successful:        {{ .Successful }}
    ErrorCount:        {{ .ErrorCount }}
    LastError:         {{ .LastError }}
{{ end }}
`
)

// Report .
type Report struct {
	Version    string
	URI        string
	Database   string
	Collection string
	Parallel   int
	Repeat     int
	Results    []*ReportQueryResult
}

// NewReport .
func NewReport(version, uri string, s *Scenario, results map[string]*ReportAggregator) *Report {
	r := &Report{
		Version:    version,
		URI:        uri,
		Database:   *s.Database,
		Collection: *s.Collection,
		Parallel:   *s.Parallel,
		Repeat:     *s.Repeat,
	}
	for _, res := range results {
		err := "nil"
		success := res.LastError == nil
		if !success {
			err = res.LastError.Error()
		}
		totalTime := time.Duration(int64(res.WorkTotal) / int64(*s.Parallel))
		queryAvg := time.Duration(0)
		if res.QueryCount > 0 {
			queryAvg = time.Duration(int64(totalTime) / int64(res.QueryCount))
		}
		changeAvg := time.Duration(0)
		if res.ChangeCount > 0 {
			changeAvg = time.Duration(int64(totalTime) / int64(res.ChangeCount))
		}
		eps := float64(0)
		if totalTime > 0 {
			eps = float64(res.QueryCount) / totalTime.Seconds()
		}
		rqr := &ReportQueryResult{
			Name:        *res.Definition.Name,
			Action:      string(*res.Definition.Action),
			QueryCount:  res.QueryCount,
			QueryAvg:    queryAvg,
			ChangeCount: res.ChangeCount,
			ChangeAvg:   changeAvg,
			EPS:         eps,
			TotalTime:   totalTime,
			Successful:  success,
			ErrorCount:  res.ErrorCount,
			LastError:   err,
		}
		r.Results = append(r.Results, rqr)
	}
	return r
}

// ReportQueryResult .
type ReportQueryResult struct {
	Name        string
	Action      string
	QueryCount  int
	QueryAvg    time.Duration
	ChangeCount int
	ChangeAvg   time.Duration
	EPS         float64
	TotalTime   time.Duration
	Successful  bool
	ErrorCount  int
	LastError   string
}

// ReportAggregator .
type ReportAggregator struct {
	Definition  *query.Definition
	WorkerCount int

	mu          *sync.Mutex
	WorkTotal   time.Duration
	QueryCount  int
	ChangeCount int
	ErrorCount  int
	LastError   error
}

// NewReportQuery .
func NewReportQuery(d *query.Definition, c int) *ReportAggregator {
	return &ReportAggregator{
		Definition:  d,
		WorkerCount: c,
		mu:          &sync.Mutex{},
		WorkTotal:   time.Duration(0),
	}
}

// Update .
func (rq *ReportAggregator) Update(dur time.Duration, changes int, err error) {
	rq.mu.Lock()
	defer rq.mu.Unlock()
	rq.QueryCount++
	rq.WorkTotal += dur
	rq.ChangeCount += changes
	if err != nil {
		rq.ErrorCount++
		rq.LastError = err
	}
}

func parseTemplates(name string, tmpl ...string) (*template.Template, error) {
	if len(tmpl) == 0 {
		return nil, fmt.Errorf("no templates provided")
	}
	var t *template.Template
	for idx, tStr := range tmpl {
		if t == nil {
			t = template.New(fmt.Sprintf("%v-%d", name, idx))
		}
		var err error
		t, err = t.Parse(tStr)
		if err != nil {
			return nil, err
		}
	}
	return t, nil
}

// GenerateReport .
func GenerateReport(w io.Writer, r *Report) error {
	templates := []string{reportTemplate, configBlock, queryBlock}
	t, err := parseTemplates("report-template", templates...)
	if err != nil {
		return err
	}
	if err := t.Execute(w, r); err != nil {
		return err
	}
	return nil
}
